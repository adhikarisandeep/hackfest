Project Management
------------------

We have decided to use the `Extreme Programming` process model.  It
is successful because it stresses on customer satisfaction.  Instead
of delivery as much as you want and setting up a deadline as far into
the future, you can deliver the software you need as you need it.
Emphasizes teamwork Managers, customers and developers are all equal
partners of a collaborative team.

.. Figure 1: eXTreme Programming

Perhaps the biggest problem with software development is changing
requirements. Agile processes accept the reality of change versus the
hunt for complete, rigid specifications. There are domains where
requirements can't change, but most projects have changing
requirements. For most projects readily accepting changes can actually
cost less than ensuring requirements will never change.  We can
produce working software starting with the first week of development
so why not show it to the customer? We can learn so much more about
the project requirements in the context of a working system.  The
changes we get this way are usually the most important to implement.

Agile also means a fundamental change in how we manage our
projects. If working software is what you will deliver then
measure. Instead of managing our activities and waiting till the
project ends for software, we will manage the requirements version to
the customer. It is a hard change to make but it opens up new ways to
develop software.

Since testing is done at each and every major milestone achieve, even
if the end target is not achieved we have a second best version of
what we had hoped to achieve.

Steps of Extreme Programming
============================

 * User stories are written
 * Release Planning creates the Release Schedule
 * Make frequent small releases
 * Project has to be divided into iterations
 * Iteration planning starts each iteration

Management
==========

 * Give the team a dedicated open workspace
 * Set a sustainable pace
 * a stand up meeting starts each day
 * The Project velocity is measured
 * Move People around

Designing
=========

 * Simplicity
 * Choose a system metaphor
 * Create spike solutions to reduce risk
 * No functionality is added early
 * Refactor whenever and whenever possible

Coding
======

 * The customer is always available
 * Code must be written to agreed standards
 * Code the unit test first
 * All production code is pair programmed
 * Only one pair integrates the code at a time
 * Integration is done often
 * Set up a dedicated integration computer
 * Use collective ownership

Testing
=======

 * All code must have unit tests
 * All the code must pass all unit tests before it can be released
 * When a bug is found, tests are created
 * Acceptance tests are run often and the score is published.
